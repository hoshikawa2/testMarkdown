- Índice

- 1. DevOps com Oracle Container Pipelines ......................................................................................... 2

- 1.1. Introdução.................................................................................................................................. 3

- 1.2. Objetivos.................................................................................................................................... 4

- 1.3. Conceitos................................................................................................................................... 5

- 1.4. Artefatos Requeridos................................................................................................................ 10

- 1.5. Containerize seu aplicativo Java e automatize builds ............................................................... 11

- 1.5.1. Criar aplicativo Wercker ................................................................................................... 12

1.5.1.1. PASSO 1 : Aplicação Java Fork no GitHub .............................................................. 131.5.1.2. PASSO 2 : Crie uma conta Wercker ........................................................................ 141.5.1.3. PASSO 3 : Crie um aplicativo Wercker .................................................................... 171.5.1.3.1. Sucesso! ......................................................................................................... 20- 1.5.2. Criar e executar o pipeline de construção do Wercker ..................................................... 21

1.5.2.1. PASSO 4 : Configurar Pipelines e Workflow no Wercker ......................................... 221.5.2.2. PASSO 5 : Definir Pipeline de Construção Wercker................................................. 261.5.2.2.1. Sucesso! ......................................................................................................... 311.5.2.3. PASSO 6 : Definir Variáveis de Ambiente no Wercker ............................................. 321.5.2.3.1. Sucesso! ......................................................................................................... 351.5.2.4. PASSO 7 : Definir Pipeline de Publicação Wercker.................................................. 361.5.2.4.1. Sucesso! ......................................................................................................... 391.5.2.5. PASSO 8 : validar a execução do fluxo de trabalho ................................................. 40- 1.5.3. Indo um pouco além… ..................................................................................................... 42

- 2. Provisionar Kubernetes usando o console da OCI........................................................................ 43

- 2.1. Introdução................................................................................................................................ 45

- 2.2. Objetivos.................................................................................................................................. 46

- 2.3. Conceitos................................................................................................................................. 47

- 2.4. Artefatos Requeridos................................................................................................................ 53

- 2.5. Configurar o Oracle Cloud Infrastructure .................................................................................. 54

- 2.5.1. PASSO 1 : Faça login no painel de controle da OCI......................................................... 55

- 2.5.2. PASSO 2 : Crie um Compartimento para seus nós do Kubernetes................................... 59

- 2.5.3. PASSO 3 : Adicione uma Declaração de Política para OKE ............................................. 62

- 2.5.4. PASSO 4 : Provisão de Kubernetes usando o console da OCI......................................... 66

- 2.5.5. PASSO 5 : Inicie uma instância do Cloud Compute para gerenciamento de clusters........ 70

- 2.5.6. PASSO 6 : SSH na sua instância de computação ............................................................ 83

- 2.5.7. PASSO 7 : Preparar o OCI CLI para Cluster Access e Download kubeconfig................... 85

- 2.5.8. PASSO 8 : Instalar e testar o kubectl no seu computador local ........................................ 94

2.5.8.1. Sucesso!................................................................................................................ 100- 2.6. Configurar e executar pipelines de implantação do Oracle Container Pipelines...................... 101

- 2.6.1. PASSO 9 : Definir a especificação de implantação do Kubernetes................................. 102

2.6.1.1. Sucesso!................................................................................................................ 106- 2.6.2. PASSO 10 : Definir os Pipelines de Implantação do Oracle Container Pipelines ............ 107

- 2.6.3. PASSO 11 : Configure os pipelines de implementação no Oracle Container Pipelines... 109

2.6.3.1. Sucesso!................................................................................................................ 113- 2.6.4. PASSO 12 : Configurar variáveis de ambiente no Oracle Container Pipelines................ 114

2.6.4.1. Sucesso!................................................................................................................ 120- 2.6.5. PASSO 13 : Acionar uma nova tentativa do pipeline ...................................................... 121

- 2.6.6. PASSO 14 : Validar a implantação................................................................................. 122

2.6.6.1. Sucesso!................................................................................................................ 126- 2.7. Implantar e testar o aplicativo do catálogo de produtos .......................................................... 127

- 2.7.1. PASSO 15 : Transferir o ficheiro YAML do Kubernetes Product Catalog ........................ 128

- 2.7.2. PASSO 16 : implantar e testar o catálogo de produtos usando o painel do Kubernetes . 131

DevOps/Containers - 1- 1. DevOps com Oracle Container Pipelines

- Vamos falar neste workshop de casos reais em desenvolvimento de software e muito provavelmente

- você se verá em uma ou mais situações. Então mãos à obra.

- Um pouco de história…

- Estamos num momento de transição forte, onde empresas novas estão surgindo a todo momento,

- muitas delas no formato de startups; ágeis, com uso massivo de tecnologias e modelos de negócios

- disruptivos.

- Você pode estar numa empresa deste tipo, ou então pode estar em uma empresa já consolidada no

- mercado. Uma empresa com anos de estrada, com uma infra-estrutura de tecnologia já solidificada com

- inúmeros sistemas, integrações de dados, portais web para atender ao mercado, parceiros de negócios.

- O negócio já é robusto e os sistemas de software também.

- Qualquer que seja o seu momento e o de sua empresa, todas já despertaram para alguns termos na

- área de desenvolvimento de software: DevOps e Containers.

- Estas duas palavras resolvem problemas como:

- Prazos para entrega de projetos apertados;

- Implantações de softwares mal sucedidas;

- Mobilização de pessoal para implantação de software, muitas vezes de forma agendada e fora do

- expediente comercial;

- Gasto excessivo de tempo e recursos para testes de software;

- Gasta-se mais tempo em provisionamento de infra-estrutura, configuração e correção de problemas do

- que planejar e implementar;

- Falhas na previsibilidade de custo dos projetos;

- Processo pouco sedimentado para gestão do ciclo de vida do desenvolvimento de software;

- Performance dos sistemas;

- Impossibilidade de escalar a performance;

- Downtime excessivo das implantações;

- Bugs e imprevistos;

- E muitos outros problemas no dia-a-dia da área de tecnologia da informação.

Pagina 2 de 134DevOps/Containers - 1- 1.1. Introdução

- Este é o primeiro de vários laboratórios que fazem parte do workshop Oracle Native Cloud Container

- Development. Este workshop o guiará pelo processo de mover um aplicativo existente para um pipeline

- de CI / CD em contêiner e implantá-lo em um cluster do Kubernetes no Oracle Public Cloud.

- Você terá 2 personas durante o workshop. O Lead Person Developer será responsável por configurar

- as partes do processo automatizado de construção e implementação que envolvem detalhes sobre o

- próprio aplicativo. O DevOps Engineer Persona configurará a infraestrutura de nuvem e provisionará o

- cluster do Kubernetes. Para contêiner e automatizar a criação e a implantação desse aplicativo, você

- utilizará os pipelines Wercker para CI / CD, o Oracle Cloud Infrastructure Registry para um registro

- contêiner Docker e o Oracle Container Engine para Kubernetes (OKE) para provisionar um cluster

- Kubernetes no Oracle Cloud. A infraestrutura.

- Durante este laboratório, você assumirá a Personagem do desenvolvedor líder e trabalhará na

- contenção de seu aplicativo Java existente. Você configurará o Wercker para monitorar o repositório de

- código-fonte do seu aplicativo para confirmações e disparará automaticamente um pipeline de

- desenvolvimento, teste e pacote, o que resultará em uma imagem do Docker de seu aplicativo que está

- pronta para ser implantada.

Pagina 3 de 134![I1](images/I1)

DevOps/Containers - 1- 1.2. Objetivos

- Containerize seu aplicativo Java e automatize o build e o

- deployment

- Criar aplicativo Wercker

- Aplicação Java Fork no GitHub

- Crie uma conta Wercker

- Crie o aplicativo Wercker

- Crie e execute pipelines de Wercker

- Configurar pipelines e fluxo de trabalho no Wercker

- Definir Pipeline de Build Wercker

- Definir variáveis de ambiente no Wercker

- Definir Pipeline de Publicação Wercker

- Validar a execução do fluxo de trabalho

Pagina 4 de 134DevOps/Containers - 1- 1.3. Conceitos

- DevOps: é um termo utilizado para descrever um conjunto de práticas para os processos de

- desenvolvimento de software, provisionamento da infra-estrutura e integração das áreas envolvidas

- através da adoção de automatização e uso de ferramentas.

- Continuous Integration (CI): é uma prática de desenvolvimento de software na qual os membros de

- um time integram seu trabalho frequentemente. Geralmente cada pessoa integra pelo menos

- diariamente – podendo haver múltiplas integrações por dia. Cada integração é verificada por um build

- automatizado (incluindo testes) para detectar erros de integração o mais rápido possível. Muitos times

- acham que essa abordagem leva a uma significante redução nos problemas de integração e permite

- que um time desenvolva software coeso mais rapidamente.

Pagina 5 de 134![I2](images/I2)

DevOps/Containers - 1Pagina 6 de 134- Continous Delivery (CD): A Entrega Contínua pode ser vista como nada mais que o próximo passo da

- Integração Contínua. Uma vez a aplicação tenha seu build, este é entregue para QA para teste e então

- para Produção. A Entrega Contínua às vezes é confundida com a Implantação Contínua. A implantação

- contínua significa que cada mudança passa pelo pipeline e automaticamente é colocada em produção,

- resultando em muitas implementações de produção todos os dias. Entrega contínua apenas significa

- que você é capaz de fazer implantações frequentes, mas pode optar por não fazê-lo, geralmente devido

- aos clientes que preferem uma velocidade mais lenta de implantação. Para fazer a implantação

- contínua, você deve estar fazendo a entrega contínua.

![I3](images/I3)

DevOps/Containers - 1Pagina 7 de 134- Builds Automatizados: É uma forma de garantir que problemas decorrentes de ações manuais possam

- afetar a qualidade de entrega do pacote de software para implantação. Entende-se então que, pode-se

- criar scripts para executar builds de forma automatização, garantindo assim um padrão de qualidade

- superior na execução deste passo.

- Deployments Automatizados: É outra forma de garantir que problemas por ações manuais possam

- afetar a qualidade de entrega do pacote de software para implantação. Através de scripts, é possível

- automatizar o processo de implantação e garantir assim a qualidade.

- Pipeline: É o processo que engloba a entrega do software de forma continua, incremental, com

- qualidade e de forma automatizada. Este processo é representado por uma ou mais ferramenta(s) e é

- muitas vezes representado de forma gráfica como uma esteira de execução de ações, onde é possível

- ver cada passo do processo.

![I4](images/I4)

DevOps/Containers - 1- Oracle Container Pipelines (Wercker): É a ferramenta da Oracle para a criação do Pipeline de Entrega

- Contínua.

- Script YAML: É um recurso do Oracle Container Pipelines para direcionar o funcionamento das ações

- dentro da ferramenta. Através de scripts no formato padrão de mercado YAML, é possível escrever

- código para automatizar, padronizar e garantir a qualidade da entrega.

- Variáveis de Ambiente: O Oracle Container Pipelines conta com o recurso de variáveis de ambiente.

- Através do uso de variáveis, é possível generalizar e configurar o pipeline para agir de forma flexível e

Pagina 8 de 134![I5](images/I5)

![I6](images/I6)

DevOps/Containers - 1- segura pois estas variáveis podem ser utilizadas nos scripts, evitando-se assim de ter que escrever o

- mesmo script para vários ambientes diferentes.

- GitHub: O github é uma das ferramentas para gestão de repositórios de código-fonte dentre diversas

- outras no mercado. Ela possui um conjunto de comandos para a gestão do código-fonte, onde é

- possível controlar a versão do código, branches, merges. Existem outras ferramentas, inclusive o git

- Oracle, compatível com todos os comandos do github e que está dentro da nuvem Oracle.

- Commit: É o termo utilizado dentro da gestão de código-fonte, através de ferramentas como o github,

- para descrever o ato do desenvolvedor para documentar e confirmar uma alteração em código para o

- repositório, marcando assim este código. Esta marcação é importante no processo de pipeline.

- Merge: É o termo utilizado quando você deseja juntar 2 versões do mesmo código-fonte, muito

- comumente utilizado quando dois ou mais desenvolvedores alteram o mesmo código-fonte.

- Fork: É o termo utilizado quando você deseja realizar um desenvolvimento de software próprio mas

- baseado em algum outro pré-existente dentro de uma comunidade que utilizar a mesma ferramenta de

- gestão de código-fonte. Quando você executa um fork, uma marcação é adicionada no software original

- informando que alguém fez um fork e esta versão é copiada para seu repositório. A partir deste ponto,

- você pode realizar alterações. Você ainda pode realizar o commit de seu código-fonte e devolver como

- contribuinte para o repositório original, onde o código pode sofrer merge para incorporar suas

- alterações.

- Docker: Containers são ambientes similares a máquinas virtuais (com várias vantagens), propícios para

- receber o deployment de aplicações. Algumas de suas vantangens são: permitir escalonamento,

- performance, flexibilidade em comunicação, integração, padronização, provisionamento, replicação

- entre várias outras. São os famosos containers de aplicações.

Pagina 9 de 134DevOps/Containers - 1- 1.4. Artefatos Requeridos

- Para este laboratório, você precisará de uma conta do

- Github . Use o seguinte link para configurar:

- uma conta do GitHub

Pagina 10 de 134DevOps/Containers - 1- 1.5. Containerize seu aplicativo Java e

- automatize builds

- Nesta etapa, utilizaremos uma aplicação com código-fonte já pronto chamada twitter-feed-oke

- que está disponível no github. Para este lab, faremos uma série de alterações no código-fonte,

- por isso, será preciso utilizar alguma ferramenta para gestão de código-fonte. Em nosso caso,

- utilizaremos o github. Para que você possa fazer alterações, antes é preciso que você copie o

- código-fonte desta aplicação para seu repostório, uma vez que não é possível alterar no

- repositório original. Logo, você irá realizar um FORK deste projeto original.

Pagina 11 de 134DevOps/Containers - 1- 1.5.1. Criar aplicativo Wercker

- Após a criação de sua conta no Oracle Container Pipeline e executar o fork no github da aplicação para

- seu repositório, será possível configurar uma esteira de pipeline. Então vamos primeiramente criar uma

- aplicação.

Pagina 12 de 134DevOps/Containers - 1- 1.5.1.1. PASSO 1 : Aplicação Java Fork no

- GitHub

- • De qualquer navegador, vá para:

- https://github.com/derekoneil/twitter-feed-oke

- • Clique em Fork no canto superior direito do navegador. Entre se solicitado.

- OBSERVAÇÃO: Se solicitado, opte por bifurcar o repositório na sua conta (isso pode ocorrer se sua

- conta também for membro de uma organização no GitHub).

Pagina 13 de 134![I7](images/I7)

DevOps/Containers - 1- 1.5.1.2. PASSO 2 : Crie uma conta Wercker

- O Oracle Container Pipelines é uma ferramenta fácil de usar, de forma intuitiva e muito visual, é

- possivel configurar todo o pipeline de entrega continua através desta ferramenta. Automatize os

- processos de BUILD, TESTE e DEPLOYMENT através de código como infra-estrutura (Code as

- Infrastructure). Dentro do portal estão disponíveis muitos e muitos scripts para automatização de passos

- já prontos para agilizar ainda mais a criação do pipeline. São scripts que integram várias ferramentas de

- mercado.

- OBSERVAÇÃO *Se você já possui uma conta Wercker , use sua conta para entrar no Wercker e

- vá para o *PASSO 3 . Se você não associou sua conta existente do Wercker à sua conta do GitHub,

- você pode fazê-lo no menu Configurações-> Conexões do Git , localizado no menu suspenso do

- usuário no canto superior direito do Wercker .

- • Em uma nova guia do navegador, acesse:

- http://app.wercker.com/

- • Clique em Inscrever-se no canto superior direito do navegador. Como alternativa, se você já se

- inscreveu para uma conta Wercker , clique em log in e faça login com o GitHub e pule para o PASSO

- 3 .

- • Clique em Inscreva-se usando o GitHub

- • Clique no botão verde Autorizar Wercker

Pagina 14 de 134![I8](images/I8)

![I9](images/I9)

DevOps/Containers - 1Pagina 15 de 134- • Digite um nome de usuário e seu endereço de e-mail para completar sua criação de conta Wercker

![I10](images/I10)

DevOps/Containers - 1Pagina 16 de 134![I11](images/I11)

DevOps/Containers - 1- 1.5.1.3. PASSO 3 : Crie um aplicativo

- Wercker

- • Se este for seu primeiro aplicativo Wercker , clique no botão azul Criar seu primeiro aplicativo . Se

- você já tem aplicativos em sua conta Wercker , clique no botão mais no canto superior direito do

- navegador e selecione Adicionar aplicativo :

- • Deixe as seleções padrão de sua conta para o proprietário e GitHub para o SCM e clique em Avançar

Pagina 17 de 134![I12](images/I12)

![I13](images/I13)

- • Clique no repositório twitter-feed- oke que aparece na lista de seus repositórios GitHub, depois clique

- em Next

DevOps/Containers - 1- • Deixe a seleção padrão de checkout sem uma chave SSH e clique em Next

- • Clique em Criar

Pagina 18 de 134![I14](images/I14)

![I15](images/I15)

![I16](images/I16)

- • Não gere um arquivo wercker.yml – vamos criar um em uma etapa posterior.

DevOps/Containers - 1Pagina 19 de 134- 1.5.1.3.1. Sucesso!

DevOps/Containers - 1Pagina 20 de 134![I17](images/I17)

DevOps/Containers - 1- 1.5.2. Criar e executar o pipeline de

- construção do Wercker

- No processo manual de entrega de software, você precisa primeiro pegar seu código-fonte

- (somente aqueles arquivos que estão devidamente devolvidos no repositório com commit),

- compilar (build), montar o pacote de implantação e implantar este pacote no ambiente

- desejado. Quando falamos de pipeline, estamos oraganizando estes passos de forma

- automatizada, padronizada e continua. Automatizada porque, uma vez configurado, todas as

- vezes que o pipeline for acionado (em nosso caso, o acionamento ocorrerá exatamente quando

- algum desenvolvedor realizar um commit no repositório de código-fonte), o processo do

- pipeline entrará em funcionamento. Padronizado porque iremos configurar os pipelines através

- de diagramas, scripts e variáveis. Uma vez definidos os passos, o pipeline sempre funcionará

- desta forma. E finalmente de forma continua porque este processo nunca para, ou seja, todas

- as vezes em que houver commit no repositório, sempre entrará em funcionamento. Nesta

- etapa, iremos configurar um script para pegar o código-fonte e executar um build deste código.

- O script será construído em script YML onde será preciso definir qual a linguagem de

- programação em que o código-fonte foi escrito, qual o processo de build a ser adotado (Maven

- é uma ferramenta muito conhecida no meio Java para esta atividade).

Pagina 21 de 134DevOps/Containers - 1- 1.5.2.1. PASSO 4 : Configurar Pipelines e

- Workflow no Wercker

- • Navegue até a página do Wercker para o aplicativo recém-criado (você já estará nessa página se

- acabou de concluir o PASSO 3 ). Observe que você está visualizando a guia “ Runs” . É aqui que

- qualquer execução do seu fluxo de trabalho será registrada.

- • Clique na guia Workflows . Você verá que a Wercker criou o início de um fluxo de trabalho para você

- já. Esse fluxo de trabalho é acionado por um commit do Git e ele executará um pipeline chamado build .

Pagina 22 de 134![I18](images/I18)

DevOps/Containers - 1- • O pipeline de build será usado para construir e testar a unidade em nosso aplicativo. Vamos criar um

- novo pipeline para armazenar a imagem do Docker resultante em um repositório do Docker Hub. Clique

- no botão Adicionar novo pipeline .

- • Preencha o push-release para o nome do pipeline e o nome YML do pipeline e clique em Create.

Pagina 23 de 134![I19](images/I19)

![I20](images/I20)

![I21](images/I21)

- • Você será apresentado com a tela da variável de ambiente do pipeline. Não precisamos adicionar

- nenhuma variável de ambiente específica do pipeline, portanto basta clicar na guia Workflows para

- retornar ao editor de fluxo de trabalho.

- • Clique no sinal de mais (+) ao lado do pipeline de construção no editor.

DevOps/Containers - 1Pagina 24 de 134![I22](images/I22)

DevOps/Containers - 1- • Na lista suspensa Executar pipeline , escolha o pipeline que acabamos de criar, push-release . Deixe

- os outros campos com seus valores padrão e clique em Adicionar .

- • Agora que temos um fluxo de trabalho configurado que irá construir e armazenar uma imagem do

- Docker contendo nosso aplicativo, precisamos definir exatamente como fazer isso em um arquivo

- chamado wercker.yml , que armazenaremos no repositório Git do nosso aplicativo .

Pagina 25 de 134![I23](images/I23)

![I24](images/I24)

DevOps/Containers - 1- 1.5.2.2. PASSO 5 : Definir Pipeline de

- Construção Wercker

- • Volte para a guia do seu navegador GitHub, mostrando sua cópia bifurcada do repositório de twitter-

- feeds e clique em Criar novo arquivo

- • No campo Nome do seu arquivo … entrada, digite wercker.yml

- • Na caixa de entrada Editar novo arquivo , cole o seguinte:

- #Use OpenJDK base docker image from dockerhub and open the application port o

- n the docker container

- box:

- id: openjdk:8

- ports:

- - 8080

- #Build our application using Maven, just as we always have

- build:

- steps:

- - install-packages:

packages: maven

- - script:

name: maven build

code: mvn clean assembly:assembly

- • Você deve ter 14 linhas de YAML no editor:

Pagina 26 de 134![I25](images/I25)

![I26](images/I26)

- • Vamos ver as duas seções do YAML que acabamos de adicionar. A primeira seção descreve uma

- caixa (box) . Uma caixa é a imagem que você deseja que o Wercker extraia de um registro do Docker

- (o padrão é o Docker Hub) para construir o pipeline. No nosso caso, precisamos de um ambiente Java

- para rodar nosso aplicativo, então vamos puxar a imagem openjdk do Docker Hub.

- A segunda seção define nosso primeiro pipeline, o pipeline de compilação (build) . Nosso pipeline de

- compilação consiste em duas etapas , uma para instalar os pacotes necessários para nosso processo

- de compilação ( install-packages ) e outra para executar um comando shell para invocar a compilação

- ( script ).

- Como nosso aplicativo é construído usando o Maven, instruiremos o Wercker a instalar o pacote Maven

- primeiro, usando a etapa install-packages . Então, construiremos o aplicativo da mesma forma que

- normalmente, chamando Maven na etapa de script .

- • Na parte inferior da página, clique no botão Confirmar novo arquivo .

DevOps/Containers - 1Pagina 27 de 134DevOps/Containers - 1- • Volte para o seu Wercker aba do navegador e clique na guia Runs. Se você for rápido o suficiente,

- verá que o Wercker foi notificado de sua nova confirmação do Git (através de um webhook ) e está

- executando seu fluxo de trabalho.

- • Você deve ver que o pipeline de build foi concluído com êxito, mas o pipeline de push-release falhou.

- Isso é o que esperávamos, pois ainda não definimos as etapas para o pipeline de push-release em

- nosso arquivo wercker.yml .

Pagina 28 de 134![I27](images/I27)

![I28](images/I28)

![I29](images/I29)

- • Clique no pipeline de build verde para detalhar os detalhes de cada etapa. Observe que você pode

- clicar em cada etapa para ver a saída do console produzida por essa etapa. No nosso caso, a saída

- inclui coisas como os resultados dos testes que o Maven executou antes de empacotar nosso aplicativo.

- Se algum comando produzir um código de status de erro, o Wercker abortará o fluxo de trabalho e o

- notificará via e-mail.

DevOps/Containers - 1Pagina 29 de 134DevOps/Containers - 1Pagina 30 de 134- • Nossa próxima etapa é definir a segunda parte de nosso fluxo de trabalho, o pipeline de push-release

- , que armazenará nossa imagem de contêiner em um repositório do Docker (OCIR) após uma

- compilação (build) bem-sucedida . Este pipeline fará uso de algumas variáveis de ambiente, então

- vamos configurar primeiro.

![I30](images/I30)

- 1.5.2.2.1. Sucesso!

DevOps/Containers - 1Pagina 31 de 134![I31](images/I31)

DevOps/Containers - 1- 1.5.2.3. PASSO 6 : Definir Variáveis de

- Ambiente no Wercker

- Iremos agora complementar a definição do pipeline configurando então o processo de Publish, ou seja,

- definiremos onde será implantado o pacote recém compilado. Em nosso caso, iremos implementar em

- containers Docker. Só que antes de definirmos o script para a publicação desta aplicação em containers

- Docker, precisamos definir as credenciais e local de implantação. Para isto, criaremos algumas

- variáveis para permitir que o script seja o mesmo para todos que estejam utilizando este lab para

- publicar a aplicação. O que você deverá alterar serão somente estas variáveis, informando o conteúdo

- delas conforme seu próprio ambiente.

- • Na sua guia do navegador Wercker , clique na guia Ambiente .

- • Crie uma variável de ambiente preenchendo as caixas Chave e Valor e clicando em Adicionar .

- Certifique-se de clicar em Adicionar após cada variável de ambiente ou eles não serão salvos. Repita

- este passo para cada variável listada abaixo.

- Valor chave:

- DOCKER_USERNAME <seu nome de tenant> / <seu-oracle-nuvem-nome de usuário>

- DOCKER_REGISTRY iad.ocir.io

- DOCKER_REPO <nome do registry> / twitter-feed

Pagina 32 de 134![I32](images/I32)

DevOps/Containers - 1- !

- !

- !

- !

- NOTA IMPORTANTE

- Substitua < your-tenancy-name > e < your-oracle-cloud-username > nos valores das

- variáveis pelo nome do tenancy e o nome de usuário específicos para sua conta na

- nuvem.

- NOTA IMPORTANTE

- Seu nome de locação pode ser encontrado no menu Usuário no OCI Console:

- NOTA IMPORTANTE

- Seu nome de usuário do Oracle Cloud é o endereço de e-mail que você usou quando

- criou sua conta de avaliação

- NOTA IMPORTANTE

- O valor DOCKER_REGISTRY acima presume que sua conta do Oracle Cloud está na

- região do iad , também conhecida como US-Ashburn . Vamos confirmar ou corrigir isso

- no próximo laboratório.

Pagina 33 de 134![I33](images/I33)

![I34](images/I34)

![I35](images/I35)

DevOps/Containers - 1- !

- Estas são todas as variáveis de ambiente que podemos preencher neste momento. No

- entanto, precisaremos fornecer mais uma informação ao Wercker antes que possamos

- enviar uma imagem com êxito para o repositório OCIR Docker – um token de

- autenticação OCI. Entraremos no console da OCI e geraremos esse token no Lab 200.

- Por enquanto, vamos concluir a configuração do pipeline de push-release no Wercker

- para que ele esteja pronto para ser lançado assim que tivermos o token.

Pagina 34 de 134- 1.5.2.3.1. Sucesso!

DevOps/Containers - 1Pagina 35 de 134![I36](images/I36)

DevOps/Containers - 1- 1.5.2.4. PASSO 7 : Definir Pipeline de

- Publicação Wercker

- Uma vez definidas as variáveis conforme seu próprio ambiente cloud, agora sim é possível escrever o

- script YML para permitir a implantação de sua aplicação em um container Docker. Repare que todas as

- vezes que você faz um commit em seu código-fonte no github, o pipeline entra em funcionamento.

- • Mude para a guia do navegador do Github , clique no arquivo wercker.yml e clique no ícone de lápis

- para começar a editar.

- • Após a definição do pipeline de compilação, cole o seguinte YAML:

- #Push the docker image with our built and tested application to the Oracle Con

- tainer Registry

- push-release:

- steps:

- - internal/docker-push:

username: $DOCKER_USERNAME

password: $OCI_AUTH_TOKEN

repository: $DOCKER_REGISTRY/$DOCKER_REPO

registry: https://$DOCKER_REGISTRY/v2

tag: $WERCKER_GIT_BRANCH-$WERCKER_GIT_COMMIT

working-dir: /pipeline/source

ports: 8080

- cmd: sh target/bin/start

Pagina 36 de 134![I37](images/I37)

DevOps/Containers - 1- • Esta seção do YAML define nosso segundo pipeline, push-release . Ele usa um tipo de passo que não

- vimos antes, internal / docker-push . Esse é um comando desenvolvido pela Wercker , que pegará a

- imagem do pipeline atual e a enviará para um registro do Docker. Você pode, no entanto, usar um

- repositório diferente – a etapa suporta um parâmetro de repositório . Você pode encontrar mais

- informações na documentação .

- Há mais duas coisas para observar sobre essa definição de pipeline. Primeiro, o parâmetro cmd informa

- ao Docker como iniciar nosso aplicativo. Note que este é apenas o script de início gerado pelo Maven,

- exatamente como nós o teríamos iniciado fora do Docker.

- Em segundo lugar, utilizamos várias variáveis de ambiente. Estamos marcando o lançamento com o

- nome da ramificação do Git e o hash de confirmação do Git para que possamos rastrear a versão do

- nosso aplicativo em execução de volta para um commit específico do Git . Essas duas variáveis (junto

- com outras ) são disponibilizadas automaticamente pelo Wercker . As variáveis de ambiente $

- DOCKER_USERNAME , $ DOCKER_REGISTRY e $ DOCKER_REPO , por outro lado, fazem referência

- àquelas que nos definimos na etapa anterior.

- • Na parte inferior da página, clique em Confirmar alterações .

Pagina 37 de 134![I38](images/I38)

DevOps/Containers - 1Pagina 38 de 134![I39](images/I39)

- 1.5.2.4.1. Sucesso!

DevOps/Containers - 1Pagina 39 de 134![I40](images/I40)

DevOps/Containers - 1- 1.5.2.5. PASSO 8 : validar a execução do

- fluxo de trabalho

- • Como aprendemos anteriormente, ainda não temos informações suficientes para permitir que o

- Wercker envie a imagem do Docker para o OCIR – ainda precisamos gerar um token de autenticação

- OCI e armazená-lo em uma variável de ambiente Wercker . Vamos ver o que aconteceu com a nossa

- execução do fluxo de trabalho. Mude para a aba do navegador Wercker e clique na aba Runs dentro do

- Wercker . Você verá o fluxo de trabalho sendo executado como resultado do seu commit do Git .

- • Depois que o fluxo de trabalho terminar, você verá que o pipeline de build foi concluído com êxito,

- mas que o pipeline de push-release terminou com um erro. Isso é o que nós esperávamos. Na verdade,

- se você clicar no pipeline de push-release que falhou, verá que os usuários Anônimos só têm

- permissão para acesso de leitura na mensagem de erro de repositórios públicos , indicando nossa falta

- de um token de autenticação. Vamos para o próximo laboratório para que possamos fazer o login no

- OCI, configurar nossa infraestrutura do Kubernetes e gerar esse token.

Pagina 40 de 134![I41](images/I41)

![I42](images/I42)

![I43](images/I43)

- NOTA : Se você receber uma mensagem de erro que diz Tenant with name XYZ not found , não se

- preocupe. Sua conta na nuvem pode estar em uma região diferente da especificada na variável de

- ambiente acima. Corrigiremos isso no próximo laboratório, assim que fizermos login no console da OCI.

- Agora você está pronto para ir para o próximo laboratório: Provisionar Kubernetes usando o console da

- OCI

- ^ Voltar ao topo

DevOps/Containers - 1Pagina 41 de 134DevOps/Containers - 1- 1.5.3. Indo um pouco além…

- Até aqui, definimos o pipeline de build de nossa aplicação. Não faz muito sentido pararmos por aqui,

- pois o que interessa é executarmos o processo completo desde a alteração do código-fonte até a

- implantação em algum servidor ou container da aplicação em questão. Só assim conseguiremos ver e

- perceber todos os passos. Certo?

- Por isso, precisamos definir em que tipo de meio iremos implantar nossa aplicação. Neste workshop,

- iremos escolher a implantação em containers Docker, orquestrados por Kubernetes. Logo, vamos dar

- uma parada por aqui no assunto DevOps e vamos pular para outro assunto interessante do próximo

- workshop: Kubernetes

- Siga agora para o workshop: Provisionar Kubernetes usando o console da OCI

Pagina 42 de 134DevOps/Containers - 1- 2. Provisionar Kubernetes usando o console

- da OCI

- O que é Container Engine para Kubernetes?

- Um serviço Kubernetes gerido pronto para empresas, nativo do container e amigável para o

- programador para executar clusters de alta disponibilidade com o controlo, a segurança e o

- desempenho previsíveis do Oracle Cloud Infrastructure.

- Container Native

- Standard e Em Conformidade

- O Container Engine tira partido dos Kubernetes upstream standard, validados em relação ao programa

- de conformidade CNCF, assegurando a portabilidade nas clouds e on-premises.

- Integração do Oracle Cloud Infrastructure

- Aproveite ao máximo a integração do Container Engine com o Oracle Cloud Infrastructure para criar

- clusters de alta disponibilidade, com as integrações nativas Load Balancer, Persistent Volume Claim e

- Persistent Volume.

Pagina 43 de 134![I44](images/I44)

DevOps/Containers - 1- Gestão do Todo o Ciclo de Vida do Container

- Crie e teste imagens de containers de modo uniforme com o Container Pipelines ou com a sua

- ferramenta de CI/CD favorita. Implemente a partir do Registry, um Container Registry privado

- compatível com Docker v2 totalmente integrado.

Pagina 44 de 134DevOps/Containers - 1- 2.1. Introdução

- Este é o segundo de vários laboratórios que fazem parte do Oracle Public Cloud Container Native

- Development workshop. Este workshop o guiará pelo processo de mover um aplicativo existente para

- um pipeline de CI / CD em contêiner e implantá-lo em um cluster do Kubernetes no Oracle Public Cloud.

- Você terá 2 personas durante o workshop. O Lead Person Developer será responsável por configurar

- as partes do processo automatizado de construção e implementação que envolvem detalhes sobre o

- próprio aplicativo. O DevOps Engineer Persona configurará as partes da automação que envolvem a

- infraestrutura do Kubernetes. Para contêiner e automatizar a criação e a implantação desse aplicativo,

- você utilizará os pipelines Wercker para CI / CD, OCI Registry para um registro de contêiner e OCI

- Container Engine para Kubernetes para provisionar um cluster Kubernetes no Oracle Cloud

- Infrastructure.

- Durante este laboratório, você assumirá o DevOps Engineer Persona . Você provisionará um cluster

- Kubernetes e toda a infraestrutura necessária usando o console OCI. A OCI fornecerá as instâncias

- Virtual Cloud Network, Load Balancers, Kubernetes Master e Worker e a instância do etcd necessária

- para suportar seu cluster.

Pagina 45 de 134DevOps/Containers - 1- 2.2. Objetivos

- Automatizar a implantação para o Kubernetes

- Criar e implantar em um cluster do Kubernetes

- Configurar a infraestrutura do Oracle Cloud

- Provisionar Kubernetes usando o console da OCI

- Configurar e executar pipelines de implantação do Wercker

- Implantar e testar o aplicativo do catálogo de produtos

Pagina 46 de 134DevOps/Containers - 1- 2.3. Conceitos

- Monilítico: É a forma tradicional na construção de software, onde a arquitetura que caracteriza o

- monolítico é normalmente uma aplicação construída em uma única linguagem de programação de forma

- que o código-fonte de toda a aplicação é compilado e/ou empacotado num único artefato. Outra

- característica básica do monolítico é o fato dos códigos ou classes serem altamente inter-dependentes

- e serem difíceis de serem separados em 2 pacotes, por exemplo.

- Docker: Containers são ambientes similares a máquinas virtuais (com várias vantagens), propícios para

- receber o deployment de aplicações. Algumas de suas vantangens são: permitir escalonamento,

- performance, flexibilidade em comunicação, integração, padronização, provisionamento, replicação

- entre várias outras. São os famosos containers de aplicações.

- Scaling: Representa a possibilidade de crescimento ou diminuição do poder computacional, de recursos/

- número de instâncias e/ou performance de uma aplicação. Em contrapartida, normalmente, ao aumentar

- o scaling, temos com consequencia o aumento de custos. O mesmo de forma inversa pode ser dito

- sobre a diminuição de scaling.

Pagina 47 de 134![I45](images/I45)

![I46](images/I46)

- VM vs Container: Uma máquina virtual tem como objetivo substituir um computador físico com sistema

- operacional. Sendo assim, uma VM atende a qualquer demanda de uso de um computador como se

- fosse um real. Um container pode ser visto de muitas formas como se fosse uma VM. Algumas

- diferenças marcantes são o fato de um container não ter um sistema operacional instalado (o container

- é instanciado e executado sobre uma máquina, VM ou não, com sistema operacional); e também pelo

- fato de poder ser configurada com os componentes necessários para funcionamento (versão de JVM,

- nginx, python, a própria aplicação do desenvolvedor, etc). A estrutura de containers garante

- flexibilidade, escalabilidade, performance e padronização no processo de implantação.

DevOps/Containers - 1Pagina 48 de 134![I47](images/I47)

- Microservices: É uma nova forma de desenvolver softwares que traz como benefícios maior

- aproveitamento dos recursos computacionais, maior performance (scaling), flexibilização dos serviços

- que podem ser ofertados, otimização dos processos de testes, implantação e inter-dependência entre

- os serviços construídos e as equipes envolvidas. Largamente adotada por startups e que despertou

- interesse geral do mercado.

DevOps/Containers - 1Pagina 49 de 134![I48](images/I48)

DevOps/Containers - 1- Kubernetes: Com a troca para o desenvolvimento de serviços e aplicações voltadas como micro-

- serviços, o número de containers instanciados começou a ser um problema para gerenciamento (quer

- seja pelo número de micro-serviços, quer seja pelo número de instâncias escaladas de um mesmo

- serviço). O número passou a ser tão grande que trouxe um problema para controlar todo o ciclo de vida

- da aplicação.

- Logo, houve a necessidade de alguma ferramenta que orquestrasse este tipo de situação. Kubernetes é

- uma aplicação open-source, criada pela Google para ajudar nesta tarefa. É amplamente aceita como

- padrão de mercado.

Pagina 50 de 134![I49](images/I49)

DevOps/Containers - 1- Cluster: É a plataforma física onde todos os recursos, workers e demais componentes do Kubernetes

- são configurados e processados.

- Servidor Master: É um servidor que age como gateway e orquestrador de todos os componentes para

- o cluster

Pagina 51 de 134![I50](images/I50)

![I51](images/I51)

- Nodes: São os servidores que recebem e executam a carga de trabalho.

DevOps/Containers - 1Pagina 52 de 134![I52](images/I52)

DevOps/Containers - 1- 2.4. Artefatos Requeridos

- O laboratório a seguir requer:

- uma conta de avaliação do Oracle Cloud

Pagina 53 de 134DevOps/Containers - 1- 2.5. Configurar o Oracle Cloud Infrastructure

- Nesta seção iremos preparar o ambiente Oracle Cloud para provisionar o OKE.

- Você irá:

- Instanciar o OKE dentro de um compartimento que estará dentro de do compartimento root

- Definir a política de acesso do OKE

- Instanciar o OKE propriamente dito

- Criar uma máquina virtual para trabalhar neste lab

- Baixar o kubeconfig a partir da linha de comando do OCI (CLI)

Pagina 54 de 134DevOps/Containers - 1- 2.5.1. PASSO 1 : Faça login no painel de

- controle da OCI

- • Se você estiver usando uma conta de avaliação, deverá aguardar até receber este e-mail, indicando

- que sua conta do Oracle Cloud foi provisionada.

- !

- ATENÇÃO!

- Tenha em atenção que este email pode chegar à sua pasta de spam ou promoções

- pendente das suas definições de email.

- • Depois de receber o e- mail Introdução ao Oracle Cloud , anote seu nome de usuário, senha e

- nome da conta do Cloud .

- • De qualquer navegador, vá para:

- https://cloud.oracle.com/en_US/sign-in

- • Digite o nome da sua conta do Cloud no campo de entrada e clique no botão Meus serviços . Se

- você tiver uma conta de teste, ela pode ser encontrada em seu e-mail de boas-vindas. Caso contrário,

- isso será fornecido pelo seu instrutor da oficina.

Pagina 55 de 134![I53](images/I53)

![I54](images/I54)

DevOps/Containers - 1- • Digite seu nome de usuário e senha nos campos de entrada e clique em Entrar . Se você tiver uma

- conta de teste, elas podem ser encontradas no seu e-mail de boas-vindas. Caso contrário, estes serão

- fornecidos pelo seu instrutor do workshop.

- !

- OBSERVAÇÃO : Se você já usou sua conta de avaliação, talvez tenha sido solicitado

- que você altere a senha temporária listada no email de boas-vindas. Nesse caso, insira

- a nova senha no campo de senha.

Pagina 56 de 134![I55](images/I55)

![I56](images/I56)

- • No canto superior esquerdo do painel, clique no menu

DevOps/Containers - 1- • Clique para expandir o submenu Serviços e clique em Compute

- • Na página de login da OCI Console, digite o mesmo nome de usuário da página de login anterior. Se

- você estiver usando uma conta de avaliação e esta for a primeira vez que fizer login no OCI Console,

- digite a senha temporária no e-mail de boas-vindas da sua conta de avaliação. Se você já visitou o

- OCI Console e alterou sua senha, digite sua nova senha . Caso contrário, esta senha será fornecida

- pelo seu instrutor.

Pagina 57 de 134![I57](images/I57)

![I58](images/I58)

DevOps/Containers - 1Pagina 58 de 134![I59](images/I59)

DevOps/Containers - 1- 2.5.2. PASSO 2 : Crie um Compartimento

- para seus nós do Kubernetes

- Os compartimentos são usados para isolar recursos no seu locatário OCI. Políticas de acesso baseadas

- em função podem ser aplicadas para gerenciar o acesso a instâncias de computação e outros recursos

- dentro de um Compartimento.

- • Clique no ícone do hambúrguer no canto superior esquerdo para abrir o menu de navegação. Na

- seção Identidade do menu, clique em Compartimentos

Pagina 59 de 134DevOps/Containers - 1Pagina 60 de 134![I60](images/I60)

- o Se você já tiver um compartimento Demo , pule este passo . Caso contrário, clique em Criar

- Compartimento

DevOps/Containers - 1- o No campo Nome , insira Demo . Digite uma descrição de sua escolha. No campo Compartimento

- principal , verifique se o compartimento root está selecionado (ele terá o mesmo nome da conta do

- Oracle Cloud). Clique em Criar Compartimento .

Pagina 61 de 134![I61](images/I61)

![I62](images/I62)

DevOps/Containers - 1- 2.5.3. PASSO 3 : Adicione uma Declaração

- de Política para OKE

- • Antes que o serviço gerenciado do Oracle Kubernetes possa criar instâncias de computação em sua

- locação de OCI, devemos explicitamente conceder permissão para isso usando uma declaração de

- política. No menu de navegação do OCI Console, escolha Identidade -> Políticas .

Pagina 62 de 134DevOps/Containers - 1Pagina 63 de 134![I63](images/I63)

- • No menu suspenso Compartimento, no lado esquerdo, escolha o compartimento root . Ele terá o

- mesmo nome da sua locação OCI (Cloud Account Name).

DevOps/Containers - 1- • Clique em diretiva raiz do PSM

- • Clique no botão Add Policy Statement

- • Na caixa Statement, insira:

- e clique em Add Statement.

- allow service OKE to manage all-resources in tenancy

Pagina 64 de 134![I64](images/I64)

![I65](images/I65)

![I66](images/I66)

DevOps/Containers - 1Pagina 65 de 134![I67](images/I67)

DevOps/Containers - 1- 2.5.4. PASSO 4 : Provisão de Kubernetes

- usando o console da OCI

- • Agora estamos prontos para criar nosso cluster do Kubernetes. No menu de navegação do console

- OCI, selecione Serviços de Desenvolvedor -> Container Clusters (OKE) .

- • Na lista suspensa Compartimentos, selecione o compartimento Demo .

Pagina 66 de 134![I68](images/I68)

![I69](images/I69)

- • Clique em Criar Cluster

- • Não precisamos fazer alterações nos valores padrão neste formulário, mas vamos ver o que será

- criado quando o enviarmos.

DevOps/Containers - 1Pagina 67 de 134![I70](images/I70)

DevOps/Containers - 1Pagina 68 de 134![I71](images/I71)

![I72](images/I72)

- o Começando no topo, você notará que o cluster será criado em nosso compartimento Demo .

- o Podemos personalizar o nome deste cluster se quisermos

- o Várias versões do Kubernetes estão disponíveis, com a versão mais recente selecionada por padrão

- o O modo de criação de cluster padrão criará automaticamente uma rede de nuvem virtual para nosso

- cluster, incluindo duas sub-redes de balanceador de carga e três sub-redes para nossas VMs de

- trabalho

- o Podemos personalizar o tamanho e a quantidade de VMs de trabalho no pool de nós; Por padrão,

- obteremos 3× 1 OCPU VMs, uma em cada domínio de disponibilidade.

- o Também podemos adicionar mais pools de nós ao cluster após a criação.

- o O painel e o Tiller serão instalados por padrão.

- o Clique em Criar . Você será levado à página de detalhes do cluster. Seu cluster demorará um pouco

- para provisionar, então vamos usar esse tempo para criar uma VM na nuvem que possamos usar para

- gerenciar nosso cluster usando a linha de comando.

DevOps/Containers - 1Pagina 69 de 134DevOps/Containers - 1- 2.5.5. PASSO 5 : Inicie uma instância do

- Cloud Compute para gerenciamento de

- clusters

- • Antes de podermos lançar uma instância de computação, precisamos de duas coisas: uma Virtual

- Cloud Network para conectá-la e um par de chaves SSH para usar na autenticação. Poderíamos criar

- um novo VCN, mas como o assistente de cluster já vai criar um, vamos apenas fazer uso disso. Então,

- vamos trabalhar na criação de um par de chaves SSH para nossa instância. O método de gerar um par

- de chaves SSH dependerá do seu sistema operacional.

- *

- NOTA : Existem vários arquivos que serão baixados ou criados em sua máquina local

- durante este workshop. Recomendamos a criação de um diretório para armazená-los

- para facilitar a localização e a limpeza. Nesta etapa, você criará um diretório dentro do

- seu diretório home / user chamado container-workshop . Você é livre para mudar a

- localização e o nome deste diretório, mas o guia do laboratório assumirá que está

- localizado em ~/container-workshop/ . Você precisará modificar os comandos do

- terminal fornecidos em todo este laboratório se alterar o local ou o nome do diretório.

- Mac / Linux :

- o Abra um terminal ou janela shell e execute os seguintes comandos:

- cd ~

- mkdir container-workshop && cd container-workshop && mkdir ssh-keys && cd ssh-

- keys

- ssh-keygen -f ./ssh-key -N ""

Pagina 70 de 134DevOps/Containers - 1- Windows :

- o Se você ainda não os tem, faça o download do PuTTY e do PuTTYgen em http://www.putty.org/

- o Localize e execute puttygen.exe na pasta de instalação do PuTTY.

Pagina 71 de 134![I73](images/I73)

![I74](images/I74)

![I75](images/I75)

- o Assegure-se de que RSA ou SSH-2 RSA esteja selecionado no campo Tipo de chave para gerar (o

- que você vê depende da sua versão do PuTTY)

DevOps/Containers - 1- o Clique em Gerar

- o Mova o mouse pela área em branco conforme instruído a gerar dados aleatórios.

Pagina 72 de 134![I76](images/I76)

![I77](images/I77)

![I78](images/I78)

![I79](images/I79)

- o Clique em Salvar chave privada e, em seguida, clique em Sim para continuar salvando sem uma

- frase secreta.

DevOps/Containers - 1Pagina 73 de 134![I80](images/I80)

- o Na caixa de diálogo salvar:

- o Navegue até o diretório home / pasta do usuário (geralmente C: \ Users \ ).

- o Clique em Nova pasta e nomeie a pasta container-workshop .

DevOps/Containers - 1Pagina 74 de 134DevOps/Containers - 1Pagina 75 de 134- o Clique duas vezes na pasta do container-workshop para inseri-lo.

- o Clique em Nova Pasta novamente. Esta hora nomeia a pasta para ssh-keys .

![I81](images/I81)

DevOps/Containers - 1- o Dê um duplo clique em ssh-keys para entrar nessa pasta.

- o Por fim, nomeie a chave ssh-key.ppk e clique em Salvar .

- o Selecione e copie a chave pública usando Control-C, que é exibido na região Public key for pasting

Pagina 76 de 134![I82](images/I82)

![I83](images/I83)

DevOps/Containers - 1- into OpenSSH authorized_keys file . Cole-o em um novo arquivo de texto usando o bloco de notas

- e salve o arquivo na pasta C:\Users\nome do usuário\container-workshop\ssh-keys .

- *

- NOTA : Não use o botão Salvar chave pública, pois ele usa um formato de chave

- incompatível.

Pagina 77 de 134![I84](images/I84)

DevOps/Containers - 1- o Quando você executar o SSH em sua instância em uma etapa posterior, use o PuTTY para conectar-

- se em vez de uma sessão ssh da linha de comandos.

- o Com as chaves geradas, estamos prontos para lançar uma instância. No menu de navegação da

- Consola OCI, selecione Compute-> Instances . Verifique se você ainda está trabalhando no

- compartimento Demo usando a lista suspensa no painel esquerdo.

- • Clique no botão Criar instância .

Pagina 78 de 134![I85](images/I85)

![I86](images/I86)

![I87](images/I87)

- • Deixe as configurações de Domínio de Disponibilidade, Fonte de Imagem e Tipo de Instância nos

- padrões.

- • No campo Formato da Instância, clique em Change Shape . Usaremos uma VM de 2-OCPU, já que

- estamos usando todas as nossas VMs 1-OCPU disponíveis para nós de trabalho do Kubernetes.

DevOps/Containers - 1Pagina 79 de 134![I88](images/I88)

DevOps/Containers - 1- • No painel Browse All Shapes, marque a caixa ao lado de VM.Standard2.2 e clique em Select Shape .

- • Na área Add SSH Key, clique em Choose Files e selecione a chave pública ssh que você gerou no

- início desta etapa (por exemplo, ~/container-workshop/ssh-keys/ssh-key.pub ).

- • Faça as seguintes seleções no formulário Configurar Rede :

- o No campo VCN Compartment, assegure-se de que Demo esteja selecionado.

- o No campo VCN, verifique se oke-vcn-quick-cluster1 está selecionado (se você alterou o nome do

- cluster, a parte cluster1 desse nome será diferente).

Pagina 80 de 134![I89](images/I89)

![I90](images/I90)

![I91](images/I91)

- o No campo Subnet Compartment, assegure-se de que Demo esteja selecionado.

- o No campo Sub-rede, selecione a sub-rede que começa com oke-svclbsubnet-quick-cluster1 , que

- está na seção Public Subnets . Tome cuidado para não selecionar a sub-rede que começa com oke-

- subnet, pois esta é uma sub-rede privada (não acessível pela Internet).

DevOps/Containers - 1- • Clique em Criar

- • Você será levado à página de detalhes da instância. Aguarde a transição da sua instância do estado

- de provisionamento para o estado Running antes de prosseguir.

Pagina 81 de 134![I92](images/I92)

![I93](images/I93)

DevOps/Containers - 1Pagina 82 de 134![I94](images/I94)

DevOps/Containers - 1- 2.5.6. PASSO 6 : SSH na sua instância de

- computação

- • Sua instância agora deve estar no estado Running . Vamos SSH para a instância e instalar o utilitário

- de linha de comando que nos permitirá interagir com o nosso cluster. Ainda na página de detalhes da

- instância, localize o Endereço IP público e copie-o para a área de transferência.

- • Abra uma conexão SSH com a instância usando o seguinte método específico do sistema operacional:

- Mac / Linux

- o Abra um terminal ou janela shell

- o Execute os seguintes comandos, colando o endereço IP público da sua área de transferência no lugar

- de

- cd ~ / container-workshop / ssh-keys /

- ssh -i ssh-key opc @ <Endereço IP público>

- o Digite Yes e pressione Enter quando perguntado se deseja continuar conectando

- Windows

- o Abra o PuTTY

- o No painel Categoria, selecione Sessão e digite o seguinte:

- ? Nome do host (ou endereço IP): opc@[Endereço IP público que você copiou para a área de

- transferência]

Pagina 83 de 134![I95](images/I95)

![I96](images/I96)

DevOps/Containers - 1- ? Tipo de conexão: SSH

- ? Porta: 22

- o No painel de categoria, expanda conexão, expanda SSH e, em seguida, clique em Auth . Clique em

- Procurar e selecione sua chave privada (por exemplo, C:\Users\ container-workshop\ssh-keys\ssh-

- key.ppk ).

- o Clique em Abrir para iniciar a sessão.

Pagina 84 de 134DevOps/Containers - 1- 2.5.7. PASSO 7 : Preparar o OCI CLI para

- Cluster Access e Download kubeconfig

- Esta etapa é muito imporante antes de começar efetivamente a trabalhar com o cluster Kubernetes.

- O objetivo deste passo é disponibilizar o OCI CLI pois ele é necessário para prover o arquivo de

- configuração do Kubernetes chamado kubeconfig.

- Sem este arquivo, não é possível interagir com a interface de gestão do Kuberntes.

- Então, você irá:

- 1) Configurar o OCI CLI (interface de linha de comandos da Cloud Oracle para poder acessar os

- recursos do OKE)

- 2) Baixar o arquivo kubeconfig com o OCI CLI

- • De dentro da sessão SSH , execute o seguinte comando para instalar o OCI CLI, que permitirá a

- interação com o cluster. Você irá su no usuário root e permanecerá como o usuário root durante o

- restante desta etapa:

- sudo -s

- bash -c "$ (curl -L https://raw.githubusercontent.com/oracle/oci-cli/master/sc

- ripts/install/install.sh)"

- p.

- !

- CUIDADO : Ao copiar o comando acima, tenha cuidado para não copiar um caractere

- de nova linha no final. Se você colar o comando em sua sessão SSH e ele executar sem

- pressionar Enter, cancele o comando com Control-C , pressione a seta para cima para

- recuperá-lo do histórico e pressione Enter para executá-lo sem o caractere de nova

- linha.

Pagina 85 de 134DevOps/Containers - 1- • Para cada um dos prompts, aceite o padrão pressionando Enter

- • Digite o seguinte para redefinir seu ambiente SHELL:

- exec -l $SHELL

- • Em um navegador da Web, volte ao OCI Console e abra a página Configurações do usuário : Use o

- menu de navegação para ir para Identidade-> Usuários e selecione Exibir detalhes do usuário no

- menu de três pontos para o usuário do Cloud com o qual você fez login. Você precisará de alguns

- detalhes desta página para concluir a configuração.

Pagina 86 de 134![I97](images/I97)

![I98](images/I98)

DevOps/Containers - 1Pagina 87 de 134![I99](images/I99)

![I100](images/I100)

- • Em sua sessão SSH Digite oci setup config respondendo aos prompts da seguinte forma:

- !

- NOTA: (Você ainda é o usuário root)

- o Insira um local para sua configuração: aceite padrão pressionando enter

- o Digite um usuário OCID: No OCI Console Copie seu usuário OCID clicando em Copiar na caixa

- Informações do Usuário .

- o Insira o tenancy OCID: copie o tenancy OCID da página Detalhes do tenancy (localizada na seção

- Administração do menu de navegação da OCI)

- o Digite sua região: digite a região mostrada no canto superior direito do OCI Console. (Isso

- provavelmente será em us-ashburn-1 para este workshop)

- o Você deseja gerar um novo par de chaves RSA ?: Y

- o Insira um diretório para suas chaves a serem criadas: aceite padrão pressionando enter

- o Digite um nome para sua chave: aceite padrão pressionando enter

- o Insira uma frase secreta para sua chave privada: aceite padrão pressionando enter

- Exemplo:

DevOps/Containers - 1Pagina 88 de 134![I101](images/I101)

![I102](images/I102)

DevOps/Containers - 1Pagina 89 de 134- • Você acabou de gerar um par de chaves RSA que usaremos para autenticar você na API OCI. Clique

- de volta para voltar à página de configurações do usuário no seu navegador, clique em Adicionar

- chave pública

- o Precisamos copiar e colar a chave pública nessa caixa. Na sua sessão SSH , execute o seguinte

- comando para gerar a chave pública:

- cat /root/.oci/oci_api_key_public.pem

![I103](images/I103)

![I104](images/I104)

![I105](images/I105)

- o Selecione a chave inteira, começando com: ——- BEGIN PUBLIC KEY ——- e terminando com ——-

- END PUBLIC KEY ——- . Copie-o e cole- o na área de texto Public Key na caixa de diálogo Add Public

- Key do OCI Console. Em seguida, clique em Adicionar .

- o Agora você está pronto para fazer o download do arquivo kubeconfig usando o OCI CLI que acabou

- de instalar. No menu de navegação do OCI Console, selecione Serviços de Desenvolvedor->

- Container Clusters (OKE) e clique no nome do seu cluster, cluster1

DevOps/Containers - 1Pagina 90 de 134![I106](images/I106)

DevOps/Containers - 1- o Clique em Access Kubeconfig .

Pagina 91 de 134![I107](images/I107)

![I108](images/I108)

DevOps/Containers - 1- o Dois comandos são exibidos na caixa de diálogo. Copie e cole cada comando (um de cada vez) em

- sua sessão SSH e execute-os. O primeiro cria um diretório para armazenar o arquivo kubeconfig e o

- segundo chama o OCI CLI para fazer o download e armazenar o arquivo kubeconfig na máquina virtual

- do cliente. Em seguida, clique em Fechar .

- *

- NOTA : Copie e cole os comandos da janela OCI Console – o segundo comando abaixo

- é personalizado com o cluster OCID. Eles estão listados aqui apenas para referência.

- mkdir -p $ HOME /.kube

- oci ce cluster create-kubeconfig --cluster-id --file $ HOME/.kube/config

- o Seu arquivo kubeconfig foi baixado da OCI e armazenado em ~/.kube/config. Em sua sessão SSH ,

Pagina 92 de 134![I109](images/I109)

![I110](images/I110)

![I111](images/I111)

DevOps/Containers - 1- execute cat ~/.kube/config para gerar o conteúdo do arquivo. Copie o conteúdo e cole -o em um novo

- arquivo de texto em sua máquina local. Nomeie o arquivo kubeconfig e salve o arquivo no diretório

- container-workshop (por exemplo, ~/container-workshop/ ou C:\Users\\container-workshop\ )

- *

- NOTA : Salve o arquivo kubeconfig como um arquivo de texto simples, não como .docx,

- .rtf, .html, etc.

- o Para interagir com seu cluster e visualizar o painel, você precisará instalar a interface de linha de

- comando do Kubernetes, kubectl . Nós faremos isso em seguida.

Pagina 93 de 134![I112](images/I112)

DevOps/Containers - 1- 2.5.8. PASSO 8 : Instalar e testar o kubectl

- no seu computador local

- O kubectl é uma interface de linha de comando para executar comandos em clusters do Kubernetes. O

- kubectl procura por um arquivo chamado config no diretório $HOME/.kube. Você pode especificar outros

- arquivos kubeconfig definindo a variável de ambiente KUBECONFIG ou configurando o sinalizador

- —kubeconfig.

- • O método escolhido para instalar o kubectl dependerá do seu sistema operacional e de quaisquer

- gerenciadores de pacotes que você já possa usar. O método genérico de instalação, fazendo o

- download do arquivo binário usando curl , é fornecido abaixo ( execute o comando apropriado em um

- terminal ou prompt de comandos ). Se você preferir usar um gerenciador de pacotes, como apt-get,

- yum, homebrew, chocolatey, etc, por favor, encontre o comando específico na Documentação do

- Kubernetes .

- Windows

- Mac

- Linux

- cd% USERPROFILE%\container-workshop

- curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.11.2/bi

- n/windows/amd64/kubectl.exe

- cd ~/container-workshop

- curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s h

- ttps://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwi

- n/amd64/kubectl

- chmod + x ./kubectl

- cd ~/container-workshop

- curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s h

- ttps://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linu

- x/amd64/kubectl

- chmod + x ./kubectl

- • Na sua janela de terminal ou no prompt de comando, execute os seguintes comandos para verificar se

Pagina 94 de 134- o kubectl é capaz de se comunicar com seu cluster. Você deve ver o cluster-info para mostrar a URL

- do nó Kubernetes Master e get nodes para mostrar o endereço IP e o status de cada um dos nós de

- trabalho.

DevOps/Containers - 1- set KUBECONFIG=%USERPROFILE%\container-workshop\kubeconfig

- kubectl.exe cluster-info

- kubectl.exe get nodes

- export KUBECONFIG=~/container-workshop/kubeconfig

- ./kubectl cluster-info

- ./kubectl get nodes

- NOTA : Você deve ver no cluster-info que o mestre do Kubernetes tem um URL

- oraclecloud.com . Se ele tiver uma URL de localhost , sua variável de ambiente

- KUBECONFIG pode não estar configurada corretamente. Verifique a variável de

- ambiente no caminho e no nome do arquivo do seu arquivo kubeconfig .

- • Agora que verificamos que o kubectl está conectado ao nosso cluster, vamos

- aumentar o tempo de auto-logout padrão para que não tenhamos que continuar a

- autenticar novamente durante o workshop. Observe que o tempo de logout padrão de 15

- minutos é definido por motivos de segurança. O argumento —token-ttl = 43200” no

- comando a seguir é a única alteração que estamos fazendo no painel.

- NOTA : Os seguintes comandos são opcionais .

Pagina 95 de 134- Windows

- Mac/Linux

- ***

- *

- *

![I113](images/I113)

![I114](images/I114)

DevOps/Containers - 1- Windows

- Mac/Linux

- ***

- kubectl.exe patch deployment kubernetes-dashboard -n kube-system -p "{"spec":

- {"template": {"spec": {"containers": [{"name": "kubernetes-dashboard", "arg

- s": ["--token-ttl=43200", "--auto-generate-certificates"]}]}}}}"

- ./kubectl patch deployment kubernetes-dashboard -n kube-system -p '{"spec":

- {"template": {"spec": {"containers": [{"name": "kubernetes-dashboard", "arg

- s": ["--token-ttl=43200", "--auto-generate-certificates"]}]}}}}'

- • Agora que aumentamos o tempo limite da sessão, podemos usar o kubectl para iniciar um proxy que

- nos dará acesso ao Painel do Kubernetes por meio de um navegador da Web em um URL do host local.

- Execute o seguinte comando na mesma janela de terminal:

- Windows

- kubectl.exe proxy

- Mac/Linux

- ./kubectl proxy

- ***

- *

- NOTA : Se você receber um erro informando bind: endereço já em uso , você pode ter

- outro aplicativo em execução na porta 8001. Você pode especificar uma porta diferente

- para o proxy passando o parâmetro —port = , por exemplo, kubectl proxy —port = 8002

- . Observe que você terá que modificar o URL do painel na próxima etapa para

- corresponder a essa porta.

Pagina 96 de 134![I115](images/I115)

![I116](images/I116)

DevOps/Containers - 1- !

- Você pode optar por executar o kubectl proxy da máquina virtual. Para isto, você precisa

- fazer um tunel para acessar o dashboard do Kubernetes do seu browser local para a VM

- que você criou. Basta abrir um tunel no Putty, clique em Connecttion -> SSH -> Tunnel

- Configure os seguintes parametros:

- Source Port: 8001

- Destionation: localhost:8001

- • Deixe o servidor proxy em execução. Abra uma aba nova em seu browser e copie o link abaixo para

- abrir o dashboard Kubernetes:

- *

- http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-

- dashboard:/proxy/

- • Você é solicitado a autenticar para visualizar o painel. Clique em Escolher arquivo kubeconfig e

- selecione seu arquivo kubeconfig na pasta ~/container-workshop/kubeconfig . Clique em Abrir e , em

- seguida, clique em Entrar .

Pagina 97 de 134![I117](images/I117)

![I118](images/I118)

- • Após a autenticação, você é apresentado ao painel do Kubernetes.

DevOps/Containers - 1Pagina 98 de 134![I119](images/I119)

- • Ótimo! Temos o Kubernetes instalado e acessível – agora estamos prontos para implantar nosso

- microsserviço no cluster. O próximo passo é informar ao Wercker como e onde nós gostaríamos de

- implantar nosso aplicativo. Na sua janela de terminal , pressione Control-C para finalizar o kubectl

- proxy. Vamos precisar da janela do terminal para coletar algumas informações do cluster em outra

- etapa. Vamos iniciar o proxy novamente mais tarde.

DevOps/Containers - 1Pagina 99 de 134- 2.5.8.1. Sucesso!

DevOps/Containers - 1Pagina 100 de 134![I120](images/I120)

DevOps/Containers - 1- 2.6. Configurar e executar pipelines de

- implantação do Oracle Container Pipelines

- Este é uma etapa complementar ao workshop de DevOps com Oracle Container Pipelines.

- Neste workshop anterior, você aprendeu a como criar uma conta no Oracle Container Pipelines,

- configurar uma aplicação e um pipeline, mas não chegou a implantar nenhuma aplicação em algum

- servidor.

- É nesta etapa em que você vai experimentar finalizar todo o pipeline, implantando sua aplicação

- daquele workshop em um container orquestrado pelo Kubernentes.

Pagina 101 de 134DevOps/Containers - 1- 2.6.1. PASSO 9 : Definir a especificação de

- implantação do Kubernetes

- Uma especificação de implantação no Kubernetes é representada por um script de implantação. Este

- recurso é muito poderoso porque transforma uma implantação de modelo tradicional (GMUD), feito de

- forma manual em um processo totalmente automatizado e exato.

- Neste script, é possível descrever exatamente como o pod com a aplicação deve ser provisionado e

- implantado.

- Aqui, iremos passar exatamente pela definição de uma especificação para a nossa aplicação.

- • De um navegador, navegue até o seu repositório de feed do Twitter bifurcado no GitHub. Se você

- fechou a guia, pode voltar ao GitHub , clicando na guia Repositórios, na parte superior da página, e

- clicando no link twitter-feed-oke .

- • Clique em Criar novo arquivo

Pagina 102 de 134![I121](images/I121)

DevOps/Containers - 1Pagina 103 de 134- • No campo Nome do seu arquivo , digite kubernetes.yml.template

- • Copie o YAML abaixo e cole -o no editor de arquivos.

- apiVersion: extensions/v1beta1

- kind: Deployment

- metadata:

- name: twitter-feed-v1

- labels:

- commit: ${WERCKER_GIT_COMMIT}

- spec:

- replicas: 2

- selector:

- matchLabels:

- template:

- metadata:

- labels:

- app: twitter-feed

app: twitter-feed

commit: ${WERCKER_GIT_COMMIT}

- spec:

- containers:

- - name: twitter-feed

![I122](images/I122)

![I123](images/I123)

DevOps/Containers - 1image: ${DOCKER_REGISTRY}/${DOCKER_REPO}:${WERCKER_GIT_BRANCH}-${WERCK- ER_GIT_COMMIT}

imagePullPolicy: Always

ports:

- name: twitter-feed

containerPort: 8080

protocol: TCP

- imagePullSecrets:

- name: wercker

- ---

- apiVersion: v1

- kind: Service

- metadata:

- name: twitter-feed

- labels:

- app: twitter-feed

- commit: ${WERCKER_GIT_COMMIT}

- spec:

- ports:

- - port: 30000

- selector:

- type: ClusterIP

- targetPort: 8080

- app: twitter-feed

- ---

- Esta configuração consiste em duas partes. A primeira seção (até a linha 28) define um Deployment ,

- que informa ao Kubernetes sobre o aplicativo que queremos implantar. Nesta Implantação, instruímos o

- Kubernetes a criar dois Pods (replicas: 2) que executarão nosso aplicativo. Dentro desses pods,

- especificamos que queremos que um contêiner Docker seja executado e componha o link para a

- imagem desse contêiner usando variáveis de ambiente específicas para essa execução de fluxo de

- trabalho ( image: $ {DOCKER_REPO}: $ {WERCKER_GIT_BRANCH} – $ {WERCKER_GIT_COMMIT

- } ).

- A segunda parte do arquivo define um serviço . Um Serviço define como o Kubernetes deve expor

- nosso aplicativo ao tráfego de fora do cluster. Nesse caso, estamos solicitando que um endereço IP

- interno do cluster seja atribuído ( type: ClusterIP ). Isso significa que nosso feed do Twitter só será

- acessível de dentro do cluster. Isso é ok, porque o feed do Twitter será consumido pelo aplicativo do

- catálogo de produtos que implantaremos mais tarde. Ainda podemos verificar se o nosso feed do Twitter

- está implantado corretamente – veremos como isso será feito posteriormente.

- Um arquivo .yml é um formato comum para armazenar dados de configuração do Kubernetes. O sufixo

- .template neste arquivo, no entanto, não é um conceito do Kubernetes. Usaremos uma etapa do

- Wercker chamada bash-template para processar qualquer arquivo .template em nosso projeto,

- substituindo variáveis de ambiente no template onde aparecer $variables . Você adicionará esse

- comando a um novo pipeline na próxima etapa.

- • Na parte inferior da página, clique em Confirmar novo arquivo.

Pagina 104 de 134![I124](images/I124)

- • Desde que você tenha se comprometido com o repositório, o Wercker irá desencadear outra execução

- do seu fluxo de trabalho. Ainda não definimos os pipelines de implantação, portanto, isso resultará em

- uma nova entrada na guia Execuções do Wercker e em uma nova imagem enviada ao registro do

- contêiner. Você não precisa fazer nada com isso; você pode passar para o próximo passo.

DevOps/Containers - 1Pagina 105 de 134- 2.6.1.1. Sucesso!

DevOps/Containers - 1Pagina 106 de 134![I125](images/I125)

DevOps/Containers - 1- 2.6.2. PASSO 10 : Definir os Pipelines de

- Implantação do Oracle Container Pipelines

- Nesta etapa, iremos complementar a definição do pipeline de deployment em nosso workshop DevOps.

- • Clique no arquivo wercker.yml e, em seguida, clique no botão de lápis para começar a editar o

- arquivo.

- • Copie o YAML abaixo e cole -o abaixo dos pipelines que definimos anteriormente.

- #Deploy our container from the Oracle Container Registry to the Oracle Contain

- er Engine (Kubernetes)

- deploy-to-cluster:

- box:

- id: alpine

- cmd: /bin/sh

- steps:

- - bash-template

- - kubectl:

- name: delete secret

- server: $KUBERNETES_MASTER

- token: $KUBERNETES_AUTH_TOKEN

- insecure-skip-tls-verify: true

- command: delete secret wercker; echo delete registry secret

- - kubectl:

- name: create secret

- server: $KUBERNETES_MASTER

- token: $KUBERNETES_AUTH_TOKEN

- insecure-skip-tls-verify: true

- command: create secret docker-registry wercker --docker-server=$DOCKER_R

- EGISTRY --docker-email=nobody@oracle.com --docker-username=$DOCKER_USERNAME --

- docker-password='$OCI_AUTH_TOKEN'; echo create registry secret

Pagina 107 de 134![I126](images/I126)

DevOps/Containers - 1- - script:

- name: "Visualise Kubernetes config"

- code: cat kubernetes.yml

- - kubectl:

- name: deploy to kubernetes

- server: $KUBERNETES_MASTER

- token: $KUBERNETES_AUTH_TOKEN

- insecure-skip-tls-verify: true

- command: apply -f kubernetes.yml

- Isso definirá um novo pipeline chamado de implantar para cluster. O pipeline fará uso de um novo tipo

- de etapa: o kubectl . Se você já usou o Kubernetes antes, você estará familiarizado com o kubectl, a

- interface de linha de comando padrão para gerenciar o Kubernetes. O passo kubectl Wercker pode ser

- usado para executar comandos do Kubernetes a partir de um Pipeline.

- O Pipeline deploy-to-cluster irá preparar nosso arquivo kubernetes.yml preenchendo algumas variáveis

- de ambiente. Ele então usará o kubectl para dizer ao Kubernetes para aplicar essa configuração ao

- nosso cluster.

- o Na parte inferior da página, clique em Confirmar novo arquivo.

- o Como você executou um commit no repositório novamente, o Wercker novamente acionará uma

- execução do seu fluxo de trabalho. Ainda não configuramos os pipelines de implantação no Wercker,

- então ainda teremos um novo Run e uma nova imagem, mas não uma implantação no Kubernetes.

Pagina 108 de 134![I127](images/I127)

DevOps/Containers - 1- 2.6.3. PASSO 11 : Configure os pipelines de

- implementação no Oracle Container

- Pipelines

- • Abra o Oracle Container Pipelines em uma nova aba ou janela do navegador, ou mude para ele se

- você já o tiver aberto. Na barra de navegação superior, clique em Pipelines e , em seguida, clique em

- seu aplicativo twitter-feed-oke .

- • Na aba Runs, você pode ver que o Oracle Container Pipelines provocou outra execução de nosso

- build e publicou o fluxo de trabalho, mas não executou o nosso novo fluxo deploy-to-cluster. Isso

- ocorre porque ainda não adicionamos o novo pipeline à definição do fluxo de trabalho. Vamos fazer isso

- agora – clique na guia Workflows e clique no botão Adicionar novo pipeline .

Pagina 109 de 134![I128](images/I128)

DevOps/Containers - 1Pagina 110 de 134- • Digite deploy-to-cluster nos campos Name e YML Pipleine. Clique em Criar .

![I129](images/I129)

![I130](images/I130)

- • Clique na aba Workflows novamente para voltar ao editor.

- • Clique no botão de adição à direita do pipeline de push-release para adicionar ao fluxo de trabalho.

- Na lista suspensa Executar pipeline , selecione deploy-to-cluster e clique em Adicionar

DevOps/Containers - 1Pagina 111 de 134DevOps/Containers - 1- • Seu fluxo de trabalho geral deve ter agora três pipelines:

- • Agora temos nosso fluxo de trabalho atualizado com nossos pipelines de implantação, mas há mais

- uma coisa que precisamos fazer antes de podermos realmente implantar. Precisamos definir algumas

- variáveis de ambiente que informam ao Wercker o endereço do nosso mestre do Kubernetes e fornecer

- tokens de autenticação para o Wercker emitir comandos para o Kubernetes e OCI.

Pagina 112 de 134![I131](images/I131)

![I132](images/I132)

- 2.6.3.1. Sucesso!

DevOps/Containers - 1Pagina 113 de 134![I133](images/I133)

DevOps/Containers - 1- 2.6.4. PASSO 12 : Configurar variáveis de

- ambiente no Oracle Container Pipelines

- • Nosso primeiro passo é definir o token de autenticação do nosso cluster como uma variável de

- ambiente Wercker. Na sua janela de terminal , execute os seguintes comandos para gerar o token,

- selecione-o e copie-o para a área de transferência:

- Windows

- cd %USERPROFILE%\container-workshop

- notepad kubeconfig

- o Encontre a seção token: na parte inferior do arquivo e copie o valor do token de lá.

- Mac/Linux

- cd ~/container-workshop

- cat kubeconfig | grep token | awk '{print $2}'

Pagina 114 de 134![I134](images/I134)

DevOps/Containers - 1- • De volta à sua aba do navegador Oracle Container Pipelines, clique na aba Environment. No campo

- chave da linha vazia abaixo da última variável de ambiente, insira a chave

- KUBERNETES_AUTH_TOKEN . No campo de valor, cole o token que acabamos de copiar. Marque a

- caixa Protegida e clique em Adicionar .

- • A próxima variável de ambiente que precisamos adicionar é o endereço do mestre do Kubernetes que

- queremos implantar. Podemos obter o URL do kubectl . Execute o seguinte comando na janela do

- terminal para gerar o URL, selecione-o e copie-o para a área de transferência:

- Windows

- o Copie e cole a string server do seu arquivo kubeconfig :

Pagina 115 de 134![I135](images/I135)

![I136](images/I136)

DevOps/Containers - 1- Mac / Linux

- o Para Linux / Mac:

- echo $(./kubectl config view | grep server | cut -f 2- -d ":" | tr -d " ")

- • Na aba do navegador Wercker, adicione uma nova variável de ambiente com a chave

- KUBERNETES_MASTER . No campo de valor, cole o valor que você copiou do kubectl . O valor deve

- começar com https:// para o Oracle Containers Pipeline se comunicar com o cluster. Quando

- terminar, clique em Adicionar .

- *

- NOTA : Você também pode encontrar esse endereço na página OKE do OCI Console,

- clicando no nome do cluster para visualizar a página de detalhes:

- • A última variável de ambiente que precisamos criar no Wercker é um token para o Wercker se

- autenticar no OCI para que ele possa empurrar a imagem do Docker para o Repositório OCI (OCIR).

- Nós vamos gerar este token de autenticação no OCI Console e colá-lo em uma variável de ambiente

- Wercker. Adicione uma nova variável de ambiente com a chave OCI_AUTH_TOKEN .

Pagina 116 de 134![I137](images/I137)

![I138](images/I138)

![I139](images/I139)

DevOps/Containers - 1- • Mude para a aba do seu browser para Console OCI . Use o menu de navegação para ir para

- Identidade-> Usuários e selecione Visualizar Detalhes do Usuário no menu de três pontos para o seu

- usuário. Se você fechou a guia, faça o login novamente .

- *

- Observação : você pode ver dois usuários na lista, um que é chamado com apenas seu

- endereço de email e outro chamado oracleidentitycloudservice / your-email-address.

- Escolha o que é chamado apenas seu endereço de email.

- • No menu Recursos da página de configurações do usuário, clique em Auth Tokens . Em seguida,

- clique em Gerar token .

Pagina 117 de 134![I140](images/I140)

![I141](images/I141)

![I142](images/I142)

DevOps/Containers - 1- • No campo Descrição, insira Wercker Pipeline Token e clique em Generate Token .

- • Clique no link Copiar sob o token gerado e clique em Fechar . Volte para a guia do seu navegador

- Wercker e cole este token no campo Valor da variável de ambiente OCI_AUTH_TOKEN que você

- começou a criar anteriormente. Marque a caixa Protegido e clique em Salvar .

- • Por fim, vamos voltar e observar a variável DOCKER_REGISTRY para garantir que especificamos a

- região correta. No console da OCI , olhe no canto superior direito da região selecionada atualmente:

Pagina 118 de 134![I143](images/I143)

![I144](images/I144)

![I145](images/I145)

![I146](images/I146)

DevOps/Containers - 1- o Se a região é ashburn , então você não precisa mudar nada. O URL iad.ocir.io está correto.

- o Se a região não é Ashburn , substitua o IAD parte do DOCKER_REGISTRY variável de ambiente

- para corresponder à sua região:

- `

- Londres = lhr

- Frankfurt = fra

- Phoenix = phx

- Ashburn = iad

- o Por exemplo, se a sua região for eu-frankfurt-1 , altere a URL para fra.ocir.io e clique no botão salvar

- • Agora estamos prontos para experimentar nosso fluxo de trabalho do início ao fim. Poderíamos fazer

- isso fazendo outro commit no GitHub, já que a Wercker está monitorando nosso código-fonte. Também

- podemos acionar uma execução de fluxo de trabalho diretamente do Wercker. Vamos ver como no

- próximo passo.

Pagina 119 de 134![I147](images/I147)

![I148](images/I148)

- 2.6.4.1. Sucesso!

DevOps/Containers - 1Pagina 120 de 134![I149](images/I149)

DevOps/Containers - 1- 2.6.5. PASSO 13 : Acionar uma nova

- tentativa do pipeline

- Agora, com todo o pipeline configurado e integrado ao OKE, podemos executar o pipeline novamente,

- desta vez, a implantação será feita com sucesso e teremos nossa aplicação no ar.

- • Na sua página de aplicação Wercker em seu navegador, clique na aba Runs . Sua execução mais

- recente deve ter um pipeline de desenvolvimento bem-sucedido e um pipeline de push-release com

- falha. Clique no pipeline de envio .

- • Clique no botão Repetir .

- • Clique na aba Runs para que você possa monitorar a execução do pipeline. Dentro de um minuto, o

- pipeline de implantação deve ser concluído com êxito. Agora podemos usar o painel do Kubernetes para

- inspecionar e validar nossa implantação.

Pagina 121 de 134![I150](images/I150)

![I151](images/I151)

![I152](images/I152)

DevOps/Containers - 1- 2.6.6. PASSO 14 : Validar a implantação

- • Primeiro, validaremos que nossa imagem do Docker está visível no Registro OCI. Na guia do

- navegador da console da OCI , selecione Registro (OCIR) no menu de navegação, na categoria

- Serviços do Desenvolvedor.

- • Clique no twitter-feed para expandir a lista de imagens e, em seguida, clique em master-xxxx para

- visualizar os detalhes. Isso confirma que nossa imagem foi direcionada para o lugar certo. O git branch

- e o commit hash nos ajudam a conectar esta imagem com a versão específica do código no GitHub.

- • Se você preferir usar a linha de comando em oposição ao método do navegador da web para testar o

Pagina 122 de 134![I153](images/I153)

![I154](images/I154)

DevOps/Containers - 1- serviço, execute o seguinte comando para verificar se o nosso microserviço está retornando dados

- JSON:

- Mac / Linux / Git Bash

- Windows

- export KUBECONFIG=~/container-workshop/kubeconfig

- ./kubectl exec -it $(./kubectl get pod -l "app=twitter-feed" -o jsonpath='{.it

- ems[0].metadata.name}') -- /bin/sh -c '/usr/bin/curl -s http://$HOSTNAME:8080/

- statictweets | head -c 1000; echo'

- set KUBECONFIG=%USERPROFILE%\container-workshop\kubeconfig

- kubectl.exe get pod -l "app=twitter-feed" -o jsonpath="{.items[0].metadata.nam

- e}" > podname.txt && FOR /F usebackq %A IN (`more podname.txt`) DO kubectl.ex

- e exec -it %~A -- /bin/sh -c "/usr/bin/curl -s http://$HOSTNAME:8080/statictwe

- ets | head -c 1000; echo"

- o Se você vir dados JSON retornados, pule para o PASSO 15, onde implantaremos os outros

- componentes de nosso aplicativo de catálogo de produtos. Caso contrário, se os comandos não

- funcionarem, você não tiver o PowerShell ou preferir uma interface baseada em navegador, continue

- em:

- o Em uma janela de terminal, inicie kubectl proxy usando o seguinte comando. Sua variável de

- ambiente KUBECONFIG ainda deve ser definida a partir de uma etapa anterior. Caso contrário,

- redefina-o.

- Windows

- kubectl.exe proxy

- Mac/Linux

- ./kubectl proxy

- • Em uma guia do navegador, navegue até o Painel do Kubernetes

- • Você deve ver a página de visão geral. Na seção de pods, você deve ver dois pods de feeds do Twitter

- em execução. Clique no nome de um dos pods para ir para a página de detalhes.

Pagina 123 de 134![I155](images/I155)

- • Na página de detalhes do pod, na barra de menu superior, clique em Exec . Isso nos dará um shell

- remoto no pod, onde podemos verificar se o nosso aplicativo está funcionando.

- • No shell exibido, cole o seguinte comando e pressione Enter .

- *

- NOTA: Você pode precisar usar ctrl-shift-v para colar. Alternativamente, você pode usar

- o menu do navegador do mouse para colar o comando.

- curl -s http://$HOSTNAME:8080/statictweets | head -c 100

- • Você deve ver alguns dados JSON sendo retornados pelo nosso serviço de feed do Twitter. Nosso

- microsserviço foi implantado com sucesso! Mas o serviço de feed do Twitter é apenas uma parte do

- nosso aplicativo de catálogo de produtos. Vamos implantar o restante do aplicativo para podermos

- validar que tudo funcione como esperado. Deixe essa guia do navegador aberta, pois a usaremos

- posteriormente.

DevOps/Containers - 1Pagina 124 de 134![I156](images/I156)

![I157](images/I157)

DevOps/Containers - 1- *

- NOTA : Você pode estar se perguntando por que precisávamos usar o terminal remoto

- do Kubernetes para testar nosso aplicativo. Lembre-se do arquivo kubernetes.yml que

- criamos anteriormente – especificamos um endereço IP interno do cluster para nosso

- serviço de feed do Twitter. Isso significa que apenas outros processos dentro do cluster

- podem alcançar nosso serviço. Se quiséssemos acessar nosso serviço pela Internet,

- poderíamos ter usado um balanceador de carga.

Pagina 125 de 134- 2.6.6.1. Sucesso!

DevOps/Containers - 1Pagina 126 de 134![I158](images/I158)

DevOps/Containers - 1- 2.7. Implantar e testar o aplicativo do

- catálogo de produtos

- Aqui mostraremos como implantar uma aplicação através de um script YAML.

Pagina 127 de 134DevOps/Containers - 1- 2.7.1. PASSO 15 : Transferir o ficheiro YAML

- do Kubernetes Product Catalog

- • De um navegador, navegue até o seu repositório de feed do Twitter bifurcado no GitHub. Se você

- fechou a guia, pode voltar ao GitHub , clicando na guia Repositórios, na parte superior da página, e

- clicando no link twitter-feed-oke .

- • Clique no arquivo alpha-office-product-catalog.kubernetes.yml .

Pagina 128 de 134![I159](images/I159)

DevOps/Containers - 1Pagina 129 de 134- • Clique com o botão direito do mouse no botão Raw e escolha Salvar link como ou Salvar como . Na

- caixa de diálogo Salvar arquivo que aparece, anote o local do arquivo e clique em Salvar.

![I160](images/I160)

![I161](images/I161)

DevOps/Containers - 1- *

- NOTA : Este arquivo YAML contém a configuração de uma implantação e serviço do

- Kubernetes, bem como a configuração do nosso microsserviço de feeds do Twitter. Em

- um ambiente de desenvolvimento normal, o aplicativo de catálogo de produtos também

- seria gerenciado pelo Wercker, para que as compilações e implementações fossem

- automatizadas. Neste workshop, no entanto, você executará uma implantação única de

- uma imagem do Docker pré-criada contendo o aplicativo do catálogo de produtos no

- painel do Kubernetes.

Pagina 130 de 134DevOps/Containers - 1- 2.7.2. PASSO 16 : implantar e testar o

- catálogo de produtos usando o painel do

- Kubernetes

- • Volte para a guia do navegador do painel do Kubernetes . Se você fechou, navegue até o painel do

- Kubernetes

- • No canto superior direito do painel, clique em Criar .

- • Clique na guia Criar a partir do arquivo e , em seguida, clique no botão de três pontos para

- procurar seu arquivo. Na caixa de diálogo, selecione o arquivo YAML que você acabou de baixar do

- GitHub e clique em Abrir , depois clique em UPLOAD .

- • No menu de navegação do lado esquerdo, clique em Overview . Você deverá ver dois novos pods de

- produto-catálogo-aplicativo sendo criados e em breve mudar de estado para Em execução.

Pagina 131 de 134![I162](images/I162)

![I163](images/I163)

![I164](images/I164)

- • Em vez de um endereço IP interno do cluster, o serviço de catálogo de produtos será exposto à

- Internet por meio de um balanceador de carga. O balanceador de carga levará alguns minutos para ser

- instanciado e configurado. Vamos verificar seu status – clique em Serviços no menu do lado esquerdo

- e, em seguida, clique no serviço de catálogo de produtos .

- • Na página de detalhes do serviço, você verá um campo chamado Endpoints externos . Depois que o

- balanceador de carga concluir o provisionamento, o campo Pontos de extremidade externos será

- preenchido com um link para o aplicativo do catálogo de produtos. Se o link ainda não aparecer,

- aguarde alguns minutos, atualize seu navegador e verifique novamente. Quando o link for exibido,

- clique nele para iniciar o site em uma nova guia.

DevOps/Containers - 1Pagina 132 de 134![I165](images/I165)

![I166](images/I166)

- • Você deve ver o carregamento do site do catálogo de produtos com êxito, validando que nossa nova

- implantação e serviço do Kubernetes foi criada corretamente. Vamos testar a funcionalidade de feed do

- twitter do catálogo. Clique no primeiro produto, Crayola New Markers . O feed do twitter do produto

- deve ser exibido.

DevOps/Containers - 1Pagina 133 de 134DevOps/Containers - 1Pagina 134 de 134- *

- OBSERVAÇÃO : Você deve ter notado que não precisávamos alterar o contêiner de

- catálogo de produtos pré-criado com os URLs dos pods de feeds ou serviços do Twitter.

- O aplicativo do catálogo de produtos faz uso do Kubernetes DNS para resolver o nome

- do serviço (twitter-feed) em seu endereço IP. O DNS do Kubernetes atribui um nome

- DNS a todos os serviços definidos em seu cluster, portanto, qualquer serviço pode ser

- consultado fazendo uma consulta DNS para o nome do serviço (prefixado pelo

- namespace. Se o serviço estiver em um namespace diferente do solicitante). O servidor

- de catálogo de produtos usa o seguinte código JavaScript para fazer uma solicitação

- HTTP para o microsserviço de feed do Twitter:

- request('http://twitter-feed:30000/statictweets/color', function (error, respo

- nse, body) { ... });

- • Alguns tweets são realmente exibidos, mas não são relevantes para este produto. Parece que há um

- bug no nosso microservice de feeds do twitter! Continue até o próximo laboratório para explorar como

- fazer correções de bugs e atualizações para o nosso microsserviço.

![I167](images/I167)

